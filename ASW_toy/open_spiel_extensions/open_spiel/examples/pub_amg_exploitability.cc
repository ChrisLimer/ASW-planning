// Copyright 2021 DeepMind Technologies Limited
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <string>

#include "open_spiel/abseil-cpp/absl/flags/flag.h"
#include "open_spiel/abseil-cpp/absl/flags/parse.h"
#include "open_spiel/algorithms/cfr.h"
#include "open_spiel/algorithms/external_sampling_mccfr.h"
#include "open_spiel/algorithms/outcome_sampling_mccfr.h"
#include "open_spiel/algorithms/tabular_exploitability.h"
#include "open_spiel/spiel.h"
#include "open_spiel/spiel_utils.h"

#include "open_spiel/algorithms/get_all_infostates.h"
#include "open_spiel/algorithms/get_all_info_and_terminal_states.h"
#include "open_spiel/algorithms/json_policy.h"

#include <fstream>

#include <vector>
#include <sstream>
#include <iostream>
#include <tuple>
#include <regex>

ABSL_FLAG(std::string, game_name, "kuhn_poker", "Game to run CFR on.");
ABSL_FLAG(std::string, path, "test", "path to load/save data");
ABSL_FLAG(bool, get_all_states_to_json, false, "Retrieve all infostates and terminal states");

namespace fs = std::filesystem;
#include <nlohmann/json.hpp>
// Alias for convenience
using json = nlohmann::json;



void save_to_exploitability_to_csv(const std::vector<std::pair<int, double>>& data, const std::string& filename) {
    std::ofstream file(filename);
    if (!file.is_open()) {
        std::cerr << "Failed to open file " << filename << std::endl;
        return;
    }

    // Write header
    file << "x,y\n";

    // Write data
    for (const auto& [x, y] : data) {
        file << x << "," << y << "\n";
    }

    file.close();
}


std::vector<int> load_checkpoint_indices_from_file(const std::string& filename) {
    std::ifstream file(filename);
    std::vector<int> vec;
    int x;
    while (file >> x) {
        vec.push_back(x);
    }
    return vec;
}

std::vector<std::string> get_sorted_policy_files(const std::string& directory_path) {
  std::vector<std::pair<int, std::string>> step_file_pairs;
  std::regex pattern(R"(jax_policy_step(\d+)\.json)");

  for (const auto& entry : fs::directory_iterator(directory_path)) {
      const std::string filename = entry.path().filename().string();
      std::smatch match;
      if (std::regex_match(filename, match, pattern)) {
          int step = std::stoi(match[1].str());
          step_file_pairs.emplace_back(step, entry.path().string());
      }
  }

  // Sort by step number
  std::sort(step_file_pairs.begin(), step_file_pairs.end());

  // Extract sorted filenames
  std::vector<std::string> sorted_filenames;
  for (const auto& [step, filepath] : step_file_pairs) {
      sorted_filenames.push_back(filepath);
  }

  return sorted_filenames;
}


void saveGameStatesToJson(
    const std::vector<std::pair<std::string, std::tuple<int, int, std::vector<int>, std::vector<int>, bool>>>& data,
    const std::string& output_path
) {
    json j;

    for (const auto& [infostate, attributes] : data) {
        const auto& [turn, pl, sub, heli, det] = attributes;

        j[infostate] = {
            {"turn", turn},
            {"pl", pl},
            {"Sub", sub},
            {"Heli", heli},
            {"Det", det}
        };
    }

    std::ofstream out(output_path);
    if (!out.is_open()) {
        throw std::runtime_error("Could not open file: " + output_path);
    }

    out << j.dump(4);  // Pretty print with indentation
    out.close();
}



std::unordered_map<std::string, double> 
  ComputeHeliPlanProb(std::vector<std::pair<std::string, std::tuple<int, int, std::vector<int>, std::vector<int>, bool>>> data, 
  std::unordered_map<std::string, open_spiel::ActionsAndProbs> policy_map)
{
  std::unordered_map<std::string, double> reach_prob_map;

  for (int i=0; i<data.size(); i++)
  {
    std::string info_state = data[i].first;
    std::cout << "info_state: " << info_state << std::endl;

    auto [turn, player, sub_history, heli_history, detected] = data[i].second;
    
    if (heli_history.size()==2 && player==1)
    {

      std::string first_string = "turn: 2  pl: " + std::to_string(player) + " Sub:  Heli:  Detected: 0";
      std::string second_string = "turn: 4  pl: " + std::to_string(player) + " Sub:  Heli: " + std::to_string(heli_history[0]) + "  Detected: 0";

      std::cout << "first_string:  " << first_string << std::endl;
      std::cout << "second_string: " << second_string << std::endl;

      double prob1=0.0;
      double prob2=0.0;
      double reach_prob = 1.0;

      auto it2 = policy_map.find(second_string);
      if (it2 != policy_map.end())
      {
        
        for (int j=0; j<it2->second.size(); j++)
        {
          if (it2->second[j].first==heli_history[1])
          {
            prob2 = it2->second[j].second;
            reach_prob *= prob2;
            std::cout << "2 Found action: " << heli_history[1] << "!" << std::endl;
            break;
          }
        }


      } else {
        std::cout << "Info state  2not found.\n";
      }


      auto it1 = policy_map.find(first_string);
      if (it1 != policy_map.end())
      {
        
        for (int j=0; j<it1->second.size(); j++)
        {
          if (it1->second[j].first==heli_history[0])
          {
            prob1 = it1->second[j].second;
            reach_prob *= prob1;
            std::cout << "1 Found action: " << heli_history[0] << "!" << std::endl;
            break;
          }
        }


      } else {
        std::cout << "Info state 1 not found.\n";
      }

      
      auto it = policy_map.find(info_state);
      if (it != policy_map.end())
      {
        for (int j=0; j<it->second.size(); j++)
        {
          double prob = it->second[j].second;

          std::string heli_plan = "Heli:";
          for (int j=0; j<heli_history.size(); j++)
          {
            heli_plan +=  " " + std::to_string(heli_history[j]);
          }
          heli_plan += " " + std::to_string(it->second[j].first);
          reach_prob_map[heli_plan] = prob * reach_prob;

        }
      }

    }
  }

  return reach_prob_map;
}

std::tuple<int, int, std::vector<int>, std::vector<int>, bool> parseInfoStateString(const std::string& input)
{
    int turn = 0;
    int pl = 0;
    int pl2=0;
    std::vector<int> sub, heli;
    bool det = false;

    // std::regex pattern(
    //     R"(turn: (\d+)\s+pl: (-?\d+)\s+Sub: ((?:\d+\s*){1,4})Heli: ((?:\d+\s*){0,3})Detected: (\d+))"
    // );
    std::regex pattern(
        R"(turn: (\d+)\s+pl: (-?\d+)\s+Sub:\s*((?:\d+\s*){0,4})Heli:\s*((?:\d+\s*){0,3})Detected: (\d+))"
        // R"(turn: (\d+)\s+pl: (-?\d+)\s(-?\d+)\s+Sub:\s*((?:\d+\s*){0,4})Heli:\s*((?:\d+\s*){0,3})Detected: (\d+))"
    );

    std::smatch match;
    if (std::regex_search(input, match, pattern)) {
        turn = std::stoi(match[1]);
        pl = std::stoi(match[2]);

        std::istringstream subStream(match[3]);
        int num;
        while (subStream >> num) {
            sub.push_back(num);
        }

        std::istringstream heliStream(match[4]);
        while (heliStream >> num) {
            heli.push_back(num);
        }

        det = std::stoi(match[5]) != 0;
    } else {
        throw std::runtime_error("Input string does not match the expected format." + input);
    }

    return {turn, pl, sub, heli, det};
}





// Example code for using CFR+ to solve Kuhn Poker.
int main(int argc, char** argv) 
{
  absl::ParseCommandLine(argc, argv);
  std::shared_ptr<const open_spiel::Game> game =
      open_spiel::LoadGame(absl::GetFlag(FLAGS_game_name));
//   open_spiel::algorithms::CFRSolver cfr_solver(*game);
//   open_spiel::algorithms::CFRPlusSolver cfr_plus_solver(*game);
//   std::cerr << "Starting CFR on " << game->GetType().short_name
//             << "..." << std::endl;

//   open_spiel::algorithms::ExternalSamplingMCCFRSolver external_sampling_cfr_solver(*game);
//   open_spiel::algorithms::OutcomeSamplingMCCFRSolver outcome_sampling_cfr_solver(*game);
  std::mt19937 rng(230398247);


  std::string path = absl::GetFlag(FLAGS_path);
  size_t pos = path.find('/');
  std::string root = (pos == std::string::npos) ? path : path.substr(0, pos);

  // Create the game_state.json file that have all game states and legal actions
  std::vector<std::pair<std::string, std::tuple<int, int, std::vector<int>, std::vector<int>, bool>>> data;
  if (absl::GetFlag(FLAGS_get_all_states_to_json))
  {
    // std::vector<std::vector<std::string>> all_infostates = open_spiel::algorithms::GetAllInformationStates(*game);  // 
    std::pair<std::vector<std::vector<std::string>>, 
      std::vector<std::pair<std::string, std::vector<double>>>> all_states = open_spiel::algorithms::GetAllInformationStatesAndTerminalStates(*game);
    
    std::vector<std::vector<std::string>> all_infostates = all_states.first;
    std::vector<std::pair<std::string, std::vector<double>>> all_terminalstates = all_states.second;

    double mean_terminal_reward = 0.0;
    std::cout << "Number of terminal states: " << all_terminalstates.size() << std::endl;
    for (int i=0; i<all_terminalstates.size(); i++)
    {
      std::cout << "" << all_terminalstates[i].first << "  Return: " << all_terminalstates[i].second[0] << std::endl;
      mean_terminal_reward += all_terminalstates[i].second[0];
    }
    std::cout << "Average reward: " << mean_terminal_reward/all_terminalstates.size() << std::endl;



    std::cout << "\nNumber of Informationstates: " << all_infostates[0].size()+all_infostates[1].size() << std::endl;
    for (int i=0; i<all_infostates.size(); i++)
    {
      std::cout << "  Number of infostates for player " << i << ": " << all_infostates[i].size() << std::endl;
      for (int j=0; j<all_infostates[i].size(); j++)
      {
        std::cout << "" << all_infostates[i][j] << "" << std::endl;

        auto state_info = parseInfoStateString(all_infostates[i][j]);
        
        std::pair<std::string, std::tuple<int, int, std::vector<int>, std::vector<int>, bool>> key_state_info(all_infostates[i][j], state_info);
        data.push_back(key_state_info);
      }
    }

    std::string output_path = root + "/game_state.json";
    saveGameStatesToJson(data, output_path);
  }



  std::vector<int> checkpoint_indices = load_checkpoint_indices_from_file(absl::GetFlag(FLAGS_path) + "/jax_trained_policy/stored_checkpoint_indices.txt");



  open_spiel::algorithms::JsonPolicy json_policy(*game);

  std::filesystem::create_directory(absl::GetFlag(FLAGS_path) + "/jax_trained_policy_and_data");

  std::cout << "\nget_sorted_policy_files" << std::endl;
  std::vector<std::string> parameter_files = get_sorted_policy_files(absl::GetFlag(FLAGS_path) + "/jax_trained_policy");

  std::vector<std::pair<int, double>> exploitability_data;

  std::cout << "parameter_files: " << parameter_files.size() << std::endl;
  std::cout << "checkpoint_indices: " << checkpoint_indices.size() << std::endl;
  for (int i=0; i<parameter_files.size(); i++)
  {
    // std::cout << parameter_files[i] << std::endl;
    // std::cout << "\nLoadPolicyFromJson" << std::endl;
    json_policy.LoadPolicyFromJson(parameter_files[i]);
    // std::cout << "\nComputePolicyRewardAndReachProb" << std::endl;
    open_spiel::algorithms::PolicyTableAndReachProb policy_and_reach_prob = json_policy.ComputePolicyRewardAndReachProb();


    // std::cout << "\nExploitability" << std::endl;
    double exploitability = open_spiel::algorithms::Exploitability(*game, json_policy.GetTabularPolicy());
    std::cerr << "JSON-Policy Exploitability step " << i << " = " << exploitability << "   checkpoint_indices: "<< checkpoint_indices[i] << "  Exmploitability: " << exploitability << std::endl;

    // exploitability_data.push_back({i, exploitability});
    exploitability_data.push_back({checkpoint_indices[i], exploitability});

    // json_policy.savePolicyTableAndReachProbToJson(absl::GetFlag(FLAGS_path) + "/jax_trained_policy_and_data/jax_trained_policy_and_data" + std::to_string(i) + ".json");
    json_policy.savePolicyTableAndReachProbToJson(absl::GetFlag(FLAGS_path) + "/jax_trained_policy_and_data/jax_trained_policy_and_data" + std::to_string(checkpoint_indices[i]) + ".json");
  }

//   exploitability_data

  save_to_exploitability_to_csv(exploitability_data, absl::GetFlag(FLAGS_path) + "/exploitability.csv");

}

// ./open_spiel_extensions/build/pub_amg_exploitability --game_name=asw_small -path="./checkpoints/train_2026_02_13_4/searcher_model"